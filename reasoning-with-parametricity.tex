\begin{frame}[fragile]
\frametitle{Reasoning with parametricity}
\begin{block}{Monomorphic Signature}
\begin{itemize}
  \item Examining the signature \lstinline[style=scala]{Int => Int}
  \item We see a lot of things this function does \emph{not} do
  \item For example, it never returns the value \lstinline[style=scala]{"abc"}
  \item However, there is an unmanageable number of possible things it might do
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Reasoning with parametricity}
\begin{block}{Another monomorphic example}
\begin{itemize}
  \item Examining the signature \lstinline[style=scala]{List[Int] => List[Int]}
  \item For example, it might add all the \lstinline{Int}s and return a list arrangement that depends on whether or not the result is a prime number
  \item The possibilities are \emph{enormous}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Reasoning with parametricity}
\begin{block}{Polymorphic Signature}
\begin{lstlisting}[style=scala]
def `irrelevant`[A](x: List[A]): List[A]
\end{lstlisting}
\begin{itemize}
  \item We can immediately assert, with confidence, a lot of things about how this function works \emph{because it is polymorphic}
  \item More directly, we assert what the function does not do
  \item<2> In other words, \emph{parametricity} has improved readability
  \item<2> Really? By how much?
\end{itemize}
\end{block}
\tiny{
\begin{lstlisting}
List<A> `irrelevant`<A>(List<A> x) // C#
\end{lstlisting}
\begin{lstlisting}
<A> List<A> `irrelevant`(List<A> x) // Java
\end{lstlisting}
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Reasoning with parametricity}
\begin{lstlisting}[style=scala]
def `irrelevant`[A](x: List[A]): List[A] = 
  ...
\end{lstlisting}
\begin{theorem}Every element \lstinline{A} in the result list appears in the input. Contraposed, If \lstinline{A} is not in the input, it is not in the result\end{theorem}
\tiny{
\begin{lstlisting}
List<A> `irrelevant`<A>(List<A> x) // C#
\end{lstlisting}
\begin{lstlisting}
<A> List<A> `irrelevant`(List<A> x) // Java
\end{lstlisting}
}

\end{frame}

\begin{frame}[fragile]
\frametitle{Reasoning with parametricity}
\begin{block}{I know this because \ldots}
\begin{itemize}
  \item<1> Because I am the boss and I said so
  \item<2> Because Reliable Rob told me so
  \item<3> Because the \emph{function name} told me so
  \item<4> Because the comment told me so
  \item<5> \textbf{Because it would not have compiled otherwise}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Reasoning with parametricity}
\begin{block}{Uninhabited Example}
\begin{lstlisting}[style=scala]
def irrelevant[A, B](a: A): B = 
  ...
\end{lstlisting}
\end{block}
\begin{theorem}This function \textbf{never} returns because if it did, it would
never have compiled\end{theorem}
\tiny{
\begin{lstlisting}
List<B> `irrelevant`<A, B>(List<A> x) // C#
\end{lstlisting}
\begin{lstlisting}
<A, B> List<B> `irrelevant`(List<A> x) // Java
\end{lstlisting}
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Reasoning with parametricity}
\begin{block}{Fast and loose reasoning is morally correct \cite{danielsson2006fast}}
\small{Functional programmers often reason about programs as if
they were written in a total language, expecting the results
to carry over to non-total (partial) languages. We justify
such reasoning.}
\end{block}
What does this mean exactly?
\end{frame}
